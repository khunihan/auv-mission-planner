Underwater Vehicle Mission Planner

Web Application Video Demo:  <URL HERE>

Description: The AUV Mission Planner is a web-based application designed to help users plan and visualize autonomous underwater vehicle (AUV) missions. It allows users to define a sequence of geographic waypoints on an interactive map, set a constant speed and depth for the mission, and calculate total distance, estimated duration, and projected battery usage. The application is built using Python with the Flask framework on the backend, and JavaScript with Leaflet.js on the frontend. It is intended as a lightweight but functional tool for students, engineers, and researchers working in marine environments.

This project was developed as the final project for Harvard’s CS50x course. It provided an opportunity to apply computer science fundamentals to a real-world marine engineering context. As someone with a background in naval architecture and marine engineering, I designed this tool to simulate the basic planning process used in AUV operations while learning to build and deploy a full-stack web application.

At its core, the backend of the application is handled by app.py. This file manages Flask routes and processes user input. When a user defines mission waypoints on the frontend and submits the form, the backend calculates the total mission distance using the Haversine formula. Based on the user-defined constant speed and depth, it then computes the expected duration of the mission. Battery usage is estimated using a simplified model that assumes a constant power draw over time. These results are returned to the frontend for display, giving the user a quick overview of the mission’s estimated performance.

The user interface is defined in templates/index.html. This HTML file includes the layout of the application and embeds a Leaflet.js map. Users can interact with the map by clicking to place waypoints. A form beneath the map allows the user to enter a single speed and depth value that applies to the entire mission. Once waypoints are set and the form is submitted, the interface displays the calculated distance, estimated time, and battery usage based on the selected mission parameters. The interface is clean and intuitive, making it accessible even to users with limited technical experience.

Custom styling is handled by static/style.css, which ensures the map is correctly sized and that the user interface is visually coherent. It handles layout, colors, fonts, and spacing for all elements on the page. The interactivity of the application is managed by static/script.js, which initializes the Leaflet map, handles click events to place markers, and manages the collection and formatting of user input. This script packages the list of waypoint coordinates, along with the single speed and depth value, into a JSON object that is sent to the Flask backend for processing. Once results are received, the script updates the page dynamically to show the calculated outputs.

One key design decision in the early version of the project was to keep the mission model simple by applying a constant speed and depth to the entire mission. This made the user interface much easier to build and allowed for cleaner communication between the frontend and backend. From a planning perspective, this approach still provides meaningful estimates for total distance, time, and energy consumption—particularly for missions with relatively uniform profiles or where rough approximations are sufficient for early-stage planning.

Another important consideration was the choice of technologies. Flask was selected for the backend because of its lightweight nature, ease of use, and compatibility with Python libraries needed for geographic and mathematical calculations. Leaflet.js was chosen for the map interface due to its simplicity and open-source nature, which eliminated the need for API keys or complex authentication. Together, these tools enabled the development of a responsive and functional application that could be built and deployed quickly.

The battery model used in this version is intentionally simplistic. It assumes a fixed power consumption rate, which is scaled by the total time required to complete the mission. While real AUV power usage depends on many more variables—such as drag, maneuvering, and system overhead—this approximation was chosen to keep the scope manageable while still providing useful feedback to the user.

In the future, this version of the project could be extended in a number of ways. Adding the ability to specify speed and depth at each waypoint would allow for more realistic mission profiles and reflect operational realities more accurately. Additionally, the user interface could be expanded to support the visualization of mission tracks, exporting of plans to JSON or CSV formats, or even integration with bathymetric and ocean current data. Another possible improvement would be to allow users to select from different AUV types with varying energy efficiency characteristics.

In summary, the AUV Mission Planner provides a foundation for simulating AUV missions using geographic waypoints and user-defined parameters. Its design emphasizes simplicity, usability, and extensibility. Though basic in its initial implementation, the project demonstrates how web applications can be used to support marine operations and provides a platform for future development that could include greater realism and complexity. As a CS50x final project, it reflects a successful combination of programming skill and engineering domain knowledge applied to a meaningful and practical use case.
